#!/bin/sh

#     ____
#    / __ )___    __      __
#   / __  / _/__ / /_____/ /
#  / /_/ / _/ -_) __/ __/ _ \
# /_____/_/ \__/\__/\__/_//_/

# File:         bfetch
# Description:  Dynamic fetching tool that SuperB
# Author:       NNB
#               └─ https://github.com/NNBnh
# URL:          https://github.com/NNBnh/bfetch
# License:      GPLv3

#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.


# Values
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"

[ -x "$XDG_CONFIG_HOME/bfetch/info"  ] && INFO_COMMANDS="${BFETCH_INFO-$XDG_CONFIG_HOME/bfetch/info}"    || INFO_COMMANDS="$BFETCH_INFO"
[ -x "$XDG_CONFIG_HOME/bfetch/art"   ] && ART_COMMANDS="${BFETCH_ART-$XDG_CONFIG_HOME/bfetch/art}"       || ART_COMMANDS="$BFETCH_ART"
[ -x "$XDG_CONFIG_HOME/bfetch/color" ] && COLOR_COMMANDS="${BFETCH_COLOR-$XDG_CONFIG_HOME/bfetch/color}" || COLOR_COMMANDS="$BFETCH_COLOR"

[ -z "$BFETCH_INFO" ] && { printf 'info element commands is not found'; exit 1 }

CLASSIC_MODE="${BFETCH_CLASSIC_MODE:-false}"
CLASSIC_ART_RIGHT="${BFETCH_ART_RIGHT:-false}"
PADDING="${BFETCH_PADDING:-1}"            ; [ "$PADDING"       -ge '0' ] && { printf 'padding must be 0+'; exit 1 }
SEPARATOR="${BFETCH_SEPARATOR:-2}"        ; [ "$SEPARATOR"     -ge '0' ] && { printf 'separator must be 0+'; exit 1 }
PROMPT_HEIGHT="${BFETCH_PROMPT_HEIGHT:-1}"; [ "$PROMPT_HEIGHT" -ge '0' ] && { printf 'prompt height must be 0+'; exit 1 }

TERM_SIZE=$(stty size)
TERM_HEIGHT="${TERM_SIZE% *}"
TERM_WIDTH="${TERM_SIZE#* }"

for element in INFO ART COLOR; do
	eval "[ -n \"\$${element}_COMMANDS\" ]" && {
		eval "textart_$element=\$(script --quiet /dev/null --command \"\$${element}_COMMANDS\")"
		eval "textraw_$element=\$(printf '%s' \"\$textart_$element\" | awk '{gsub(\"\\x1B[[0-9;]*[JKmsu]\",\"\");print}')"

		eval "textart_$element=\${textart_$element//\\\\/\\\\\\\}"
		eval "textart_$element=\${textart_$element//%/%%}"
		eval "TEXTART_$element=\$textart_$element"
	}

	eval "${element}_HEIGHT=\$(( \$(printf \"\$textraw_$element\" | awk 'END {print NR}') + 0 ))"
	eval "${element}_WIDTH=\$(( \$(printf \"\$textraw_$element\" | awk 'length>=max_length {max_length=length} END {print max_length}') + 0 ))"

	eval "export BFETCH_${element}_HEIGHT=\$${element}_HEIGHT"
	eval "export BFETCH_${element}_WIDTH=\$${element}_WIDTH"
done


# Functions
print_textart() {
	element_padding="${2:+\\033[${2}C}"

	print="$print\\033[0m$element_padding${1//
/\\n$element_padding}"
}

fetch_classic() {
	[ "$CLASSIC_ART_RIGHT" = 'true' ] && order='info_color reset art' || order='art reset info_color'
	[ "$MODUL_COLOR" = 'possible' ] && [ -n "$TEXTART_COLOR" ] && [ "$COLOR_WIDTH" -gt "$INFO_WIDTH" ] && [ "$INFO_HEIGHT" -lt "$ART_HEIGHT" ] && INFO_COLOR_WIDTH="$COLOR_WIDTH" || INFO_COLOR_WIDTH="$INFO_WIDTH"
	fetch_padding_check=$(( $TERM_WIDTH - ( $ART_WIDTH + $INFO_COLOR_WIDTH + $SEPARATOR ) ))
	FETCH_PADDING=$(( $fetch_padding_check < $PADDING ? $fetch_padding_check : $PADDING ))
	group_padding='0'

	for group in $order; do
		case $group in
			'art')
				print_textart "$TEXTART_ART" "$(( $FETCH_PADDING + $group_padding ))"

				group_height="$ART_HEIGHT"
				group_padding=$(( $ART_WIDTH + $SEPARATOR ))
			;;
			'info_color')
				print_textart "$TEXTART_INFO" "$(( $FETCH_PADDING + $group_padding ))"
				info_color_height="$INFO_HEIGHT"

				[ "$MODUL_COLOR" = 'possible' ] && [ -n "$TEXTART_COLOR" ] && {
					print="$print \\n\\n"
					print_textart "$TEXTART_COLOR" "$(( $FETCH_PADDING + $group_padding ))"
					info_color_height=$(( $INFO_HEIGHT + 1 + $COLOR_HEIGHT ))
				}

				group_height="$info_color_height"
				[ "$INFO_HEIGHT" -lt "$ART_HEIGHT" ] && group_padding=$(( $INFO_COLOR_WIDTH + $SEPARATOR ))
			;;
			'reset')
				print="$print\\033[9999999D\\033[$(( $group_height - 1 ))A"
			;;
		esac
	done

	fetch_end=$(( ( $ART_HEIGHT > $info_color_height ? $ART_HEIGHT : $info_color_height ) - $group_height ))
	[ "$fetch_end" -gt '0' ] && print="$print\\033[${fetch_end}B"
}

fetch_paper() {
	[ "$MODUL_ART" = 'possible' ] && [ -n "$TEXTART_ART" ] && print_textart "$TEXTART_ART" "$(( ( $TERM_WIDTH - $ART_WIDTH ) / 2 ))"

	print="$print \\n\\n"
	print_textart "$TEXTART_INFO" "$(( ( $TERM_WIDTH - $INFO_WIDTH ) / 2 ))"

	[ "$MODUL_COLOR" = 'possible' ] && [ -n "$TEXTART_COLOR" ] && {
		print="$print \\n\\n"
		print_textart "$TEXTART_COLOR" "$(( ( $TERM_WIDTH - $COLOR_WIDTH ) / 2 ))"
	}
}


# Start
if [ "$TERM_WIDTH" -ge $(( $INFO_WIDTH + $SEPARATOR + $ART_WIDTH )) ] && [ "$TERM_HEIGHT" -ge $(( $INFO_HEIGHT + 1 + $ART_HEIGHT + 1 + $COLOR_HEIGHT + $PROMPT_HEIGHT )) ]; then
	MODUL_ART='possible'
	MODUL_COLOR='possible'

	[ "$CLASSIC_MODE" = 'true' ] && fetch_classic || fetch_paper
elif [ ! "$TERM_WIDTH" -ge $(( $INFO_WIDTH + $SEPARATOR + $ART_WIDTH )) ]; then
	if [ "$TERM_HEIGHT" -ge $(( $INFO_HEIGHT + 1 + $ART_HEIGHT + 1 + $COLOR_HEIGHT + $PROMPT_HEIGHT )) ]; then
		MODUL_ART='possible'
		MODUL_COLOR='possible'
	elif [ "$TERM_HEIGHT" -ge $(( $INFO_HEIGHT + 1 + $ART_HEIGHT + $PROMPT_HEIGHT )) ]; then
		MODUL_ART='possible'
	elif [ "$TERM_HEIGHT" -ge $(( $INFO_HEIGHT + 1 + $COLOR_HEIGHT + $PROMPT_HEIGHT )) ]; then
		MODUL_COLOR='possible'
	fi

	fetch_paper
else
	[ "$TERM_HEIGHT" -ge $(( $INFO_HEIGHT + 1 + $ART_HEIGHT + $PROMPT_HEIGHT )) ] && MODUL_ART='possible'
	[ "$TERM_HEIGHT" -ge $(( $INFO_HEIGHT + 1 + $COLOR_HEIGHT + $PROMPT_HEIGHT )) ] && MODUL_COLOR='possible'

	fetch_classic
fi

printf "\033[?25l\033[?7l\033[0m$print\033[?25h\033[?7h\n"

for element in INFO ART COLOR; do
	eval "export BFETCH_${element}_HEIGHT=''"
	eval "export BFETCH_${element}_WIDTH=''"
done


exit 0
